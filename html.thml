{
        question: "Lệnh nào sau đây dùng để thiết lập giá trị trả về của một đối tượng giả lập?",
        options: [
          "oninvokeReturn()",
          "returnValue()",
          "returnWhenCalled()",
          "when().thenReturn()"
        ],
        correct: 3
      },
      {
        question: "JUnit chủ yếu được sử dụng để làm gì?",
        options: [
          "Unit Test",
          "Debug",
          "Tích hợp liên tục",
          "Thiết kế test case"
        ],
        correct: 0
      },
      {
        question: "Làm thế nào có thể mong đợi một ngoại lệ cụ thể được đưa ra trong 1 test case JUnit?",
        options: [
          "Sử dụng annotation @ExpectException",
          "Sử dụng try-catch",
          "Sử dụng phương thức ExpectException trên đối tượng test",
          "Sử dụng phương thức assertThrows()"
        ],
        correct: 3
      },
      {
        question: "Annotation nào được sử dụng để chỉ ra một phương thức là phương thức test trong JUnit?",
        options: [
          "@Testing",
          "@Testify",
          "@TestCase",
          "@Test"
        ],
        correct: 3
      },
      {
        question: "Hàm so khớp Hamcrest nào giống toán tử &&?",
        options: [
          "all",
          "and",
          "anyOf",
          "allOf"
        ],
        correct: 1
      },
      {
        question: "Việc thực hiện các test case chức năng là một phần của",
        options: [
          "Quá trình xác minh (verification)",
          "Quá trình báo cáo kết quả test",
          "Quá trình thiết kế cấp cao",
          "Quá trình xác nhận (validation)"
        ],
        correct: 3
      },
      {
        question: "Test case Selenium IDE có ba cột: command, target và value. Cột Target lưu trữ dữ liệu gì?",
        options: [
          "Phần tử hoặc vị trí nơi lệnh được thực thi",
          "Bước tiếp theo",
          "Kết quả thực hiện của 1 bước test",
          "Mục đích của 1 bước test"
        ],
        correct: 0
      },
      {
        question: "Hàm verify() của Mockito dùng để làm gì?",
        options: [
          "So sánh kết quả thực tế với kết quả mong đợi",
          "Tạo đối tượng giả lập bán phần",
          "Tạo đối tượng giả lập toàn phần",
          "Xác minh ở phương thức có được gọi hay không"
        ],
        correct: 3
      },
      {
        question: "Giả sử đối tượng giả lập objA có 1 phương thức f(). Lệnh nào sau đây dùng để xác định phương thức f() không được gọi?",
        options: [
          "assert(objA,never()).f()",
          "verifyNoInteractions(objA)",
          "verifyNever(objA)",
          "assertNever(objA).f()"
        ],
        correct: 1
      },
      {
        question: "Phát biểu nào phù hợp nhất cho kết quả mong đợi (expected result)?",
        options: [
          "Chỉ được sử dụng trong test component",
          "Tốt nhất là giá trị khi thực thi chương trình",
          "Hữu ích nhất khi được xác định trước",
          "Chỉ quan trọng trong test hệ thống"
        ],
        correct: 2
      },
      {
        question: "Phát biểu nào sau đây đúng với Unit test?",
        options: [
          "Đó là việc xác nhận các thành phần đơn vị, được thực hiện bởi developer trong môi trường test",
          "Đó là việc xác nhận các thành phần đơn vị, được thực hiện bởi tester trong môi trường test",
          "Đó là việc xác nhận các thành phần đơn vị, được thực hiện bởi developer trong môi trường phát triển",
          "Đó là xác nhận giao diện (interface) giữa các thành phần đơn vị"
        ],
        correct: 2
      },
      {
        question: "Phát biểu nào sau đây sai về test tĩnh?",
        options: [
          "Test tĩnh có thể đưa ra các phép đo như độ phức tạp chu trình",
          "Test tĩnh yêu cầu phải chạy code",
          "Là quá trình review một tài liệu như test plan",
          "Là quá trình review source code"
        ],
        correct: 1
      },
      {
        question: "Sự khác biệt giữa lệnh assert và lệnh verify của Selenium IDE là gì?",
        options: [
          "Lệnh assert không thành công sẽ dừng kiểm tra nhưng lệnh verify không thành công thì vẫn tiếp tục",
          "Lệnh verify không thành công sẽ dừng kiểm tra nhưng lệnh assert không thành công thì vẫn tiếp tục",
          "Lệnh verify ít phổ biến hơn các lệnh assert",
          "Lệnh assert ít phổ biến hơn các lệnh verify"
        ],
        correct: 0
      },
      {
        question: "Kiểm tra thời gian chờ là",
        options: [
          "Phụ thuộc vào phần mềm và phần cứng",
          "Phụ thuộc vào phần mềm",
          "Phụ thuộc vào phần cứng",
          "Độc lập với phần mềm và phần cứng"
        ],
        correct: 0
      },
      {
        question: "Phát biểu nào sau đây đúng về phương thức thenReturn() trong Mockito?",
        options: [
          "Nó được sử dụng để xác minh rằng một phương thức đã được gọi trên một đối tượng giả",
          "Nó được sử dụng để chỉ định giá trị trả về của một lệnh gọi phương thức trên một đối tượng giả",
          "Nó được sử dụng để tạo một đối tượng giả",
          "Nó không phải là một phương thức hợp lệ trong Mockito"
        ],
        correct: 1
      },
      {
        question: "Trong test double, đối tượng stub khác với đối tượng mock như thế nào?",
        options: [
          "Mock mô phỏng kết quả xử lý của một hành động còn stub được sử dụng để xác nhận một hành động có được thực hiện không",
          "Mock là đối tượng giả còn stub là đối tượng thật",
          "Stub mô phỏng kết quả xử lý của một hành động còn mock được sử dụng để xác nhận một hành động có được thực hiện không",
          "Stub là đối tượng giả còn mock là đối tượng thật"
        ],
        correct: 2
      },
      {
        question: "Phát biểu nào sau đây đúng về phương thức when() trong Mockito?",
        options: [
          "Nó được sử dụng để xác minh rằng một phương thức đã được gọi trên một đối tượng giả",
          "Nó được sử dụng để ném một ngoại lệ khi một phương thức được gọi trên một đối tượng giả",
          "Nó được sử dụng để chỉ định hành vi của một lệnh gọi phương thức trên một đối tượng giả",
          "Nó được sử dụng để tạo một đối tượng giả"
        ],
        correct: 2
      },
      {
        question: "Phát biểu nào sau đây phù hợp cho khái niệm độ bao phủ?",
        options: [
          "Chỉ áp dụng cho unit test, không áp dụng cho system test",
          "Là thước đo một phần của tính kỹ lưỡng của bài kiểm tra",
          "Độ bao phủ nhánh là bắt buộc đối với tất cả các phần mềm",
          "Khi nào đạt được độ bao phủ 100% thì việc kiểm thử hoàn thành"
        ],
        correct: 1
      },
      {
        question: "Phát biểu nào sau đây đúng về phương thức never() của Mockito?",
        options: [
          "Nó được sử dụng để xác minh rằng một phương thức đã được gọi trên một đối tượng giả",
          "Nó được sử dụng để tạo một đối tượng giả",
          "Nó được sử dụng để xác minh rằng một phương thức không được gọi trên một đối tượng giả",
          "Nó được sử dụng để chỉ định hành vi của một lệnh gọi phương thức trên một đối tượng giả"
        ],
        correct: 2
      },
      {
        question: "assertThat(1.03, is(closeTo(1.0,0.03))) có kết quả là gì?",
        options: [
          "false",
          "true",
          "mor",
          "mail"
        ],
        correct: 1
      },
      {
        question: "Hàm nào sau đây được sử dụng để tạo một phần mock với Mockito?",
        options: [
          "spy()",
          "partialMock()",
          "halfMock()",
          "mockPartial()"
        ],
        correct: 0
      },
      {
        question: "Cách nào sau đây dùng để tạo mới 1 đối tượng giả lập bằng Mockito?",
        options: [
          "mock()",
          "createMock()",
          "new Mock()",
          "newMock()"
        ],
        correct: 0
      },
      {
        question: "Chọn phát biểu đúng cho Smoke testing",
        options: [
          "Nó được thực hiện sau khi quá trình test hệ thống kết thúc",
          "Nó là sự thay thế cho test hồi quy",
          "Nó là sự thay thế cho test chấp nhận",
          "Nó được thực hiện để đảm bảo hệ thống đã sẵn sàng trải qua quá trình kiểm tra chuyên sâu và nghiêm ngặt hơn"
        ],
        correct: 3
      },
      {
        question: "Điều quan trọng nhất về thiết kế kiểm thử sớm là",
        options: [
          "Không cần kiểm duyệt",
          "Sẽ tìm thấy tất cả các lỗi",
          "Làm cho việc chuẩn bị kiểm thử dễ dàng hơn",
          "Có thể ngăn chặn lỗi gia tăng"
        ],
        correct: 3
      },
      {
        question: "Mục đích của annotation @DisplayName trong JUnit là gì?",
        options: [
          "Để chỉ định tên của test suite",
          "Đổi tên phương pháp thử trong thời gian chạy",
          "Đặt tên hiển thị tùy chỉnh cho phương pháp thử nghiệm",
          "Hiển thị tên người chạy thử"
        ],
        correct: 2
      },
      {
        question: "Cú pháp để truy cập giá trị của biến x trong Selenium IDE là gì?",
        options: [
          "{x}",
          "x",
          "5x",
          "${x}"
        ],
        correct: 3
      },
      {
        question: "Phương thức nào được sử dụng trong JUnit để kiểm tra xem hai đối tượng có phải là cùng một thể hiện (instance) hay không?",
        options: [
          "assertSameInstance()",
          "assertInstance()",
          "assertThat()",
          "sameInstance()"
        ],
        correct: 0
      },
      {
        question: "Loại test nào được thực hiện để kiểm tra xem giao diện người dùng có dễ sử dụng không?",
        options: [
          "White Box Testing",
          "Usability Testing",
          "Security Testing",
          "Unit Testing"
        ],
        correct: 1
      },
      {
        question: "Nguồn nào sau đây là nguồn tốt nhất về 'Kết quả mong đợi' cho các testcase 'Kiểm thử chấp nhận' của người dùng?",
        options: [
          "Đặc tả chương trình",
          "Đặc tả hệ thống",
          "Yêu cầu của người dùng",
          "Kết quả thực tế"
        ],
        correct: 2
      },
      {
        question: "Hàm assertTrue('message', A) làm gì?",
        options: [
          "Khẳng định rằng điều kiện A là đúng",
          "Khẳng định rằng A chứa 'message'",
          "Khẳng định rằng điều kiện A là sai",
          "Khẳng định rằng 'message' = A"
        ],
        correct: 0
      },
      {
        question: "Phát biểu nào sau đây đúng về annotation @Spy trong Mockito?",
        options: [
          "Nó được sử dụng để tạo một đối tượng giả (mock)",
          "Nó được sử dụng để tạo một đối tượng giả một phần",
          "Nó được sử dụng để đưa các phần phụ thuộc vào một lớp kiểm tra",
          "Nó được sử dụng để xác minh rằng một phương thức đã được gọi trên một đối tượng giả"
        ],
        correct: 1
      },
      {
        question: "Phát biểu nào sau đây phù hợp nhất về kiểm thử?",
        options: [
          "Mục tiêu mục đích của kiểm thử là để chứng minh rằng chương trình hoạt động",
          "Mục đích của kiểm thử là để chứng minh rằng chương trình không có lỗi",
          "Mục đích của kiểm thử là để chứng minh rằng chương trình được thực hiện đúng phương pháp",
          "Kiểm thử là thực thi phần mềm nhằm mục đích tìm ra những khuyết điểm của phần mềm"
        ],
        correct: 3
      },
      {
        question: "Phủ lệnh và phủ nhánh có nghĩa là",
        options: [
          "Mỗi dòng lệnh đều được test",
          "Mọi câu lệnh và mọi nhánh đều được kiểm tra",
          "Tất cả các câu lệnh if đều được kiểm tra",
          "Đã kiểm tra mọi tổ hợp giá trị của câu lệnh IF trong chương trình"
        ],
        correct: 1
      },
      {
        question: "Làm cách nào để đánh giá thời gian chạy của một phương thức trong JUnit?",
        options: [
          "Sử dụng phương thức assertTimeout",
          "Sử dụng annotation @Speed",
          "Sử dụng phương thức assertSpeed",
          "Sử dụng phương thức Timeout"
        ],
        correct: 0
      },
      {
        question: "Cái nào sau đây là một CSS locator tương đương với Xpath //div[@id='example']",
        options: [
          "css=div.example",
          "css=div#example",
          "css=div@example",
          "css=div example"
        ],
        correct: 1
      },
      {
        question: "Trường hợp nào sẽ là trường hợp kiểm thử chức năng cho hệ thống đặt chỗ trực tuyến?",
        options: [
          "Kiểm tra cách hệ thống hoạt động khi số lượng lớn người dùng đang truy cập trang web",
          "Kiểm tra xem người dùng có thể đặt vé từ Mumbai đến Goa không",
          "Do thời gian đáp ứng của hệ thống",
          "Đảm bảo người già cũng có thể sử dụng dễ dàng"
        ],
        correct: 1
      },
      {
        question: "Phát biểu nào sau đây đúng về các hoạt động 'verification' trong kiểm thử?",
        options: [
          "Kiểm tra xem chúng ta đang xây dựng hệ thống có đúng không",
          "Kiểm tra xem chúng ta có đang xây dựng đúng hệ thống không",
          "Được thực hiện bởi một nhóm kiểm thử độc lập",
          "Đảm bảo rằng đó là điều người dùng thực sự muốn"
        ],
        correct: 1
      },
      {
        question: "Một kỹ thuật kiểm thử phổ biến trong quá trình Unit test là",
        options: [
          "Kiểm tra độ phủ lệnh và phủ nhánh",
          "Đánh giá năng suất",
          "Kiểm tra tính khả dụng",
          "Kiểm tra tính bảo mật"
        ],
        correct: 0
      },
      {
        question: "Annotation nào xác định 1 phương thức test có tham số?",
        options: [
          "@ParameterizedTest",
          "@DataDrivenTest",
          "@Parameters",
          "@TestWithParams"
        ],
        correct: 0
      },
      {
        question: "Phát biểu nào sau đây đúng về quá trình xây dựng phần mềm theo hướng tiếp cận TDD?",
        options: [
          "Trải qua 3 giai đoạn: test, code, retest",
          "Trải qua 2 giai đoạn: test trước, code sau",
          "Trải qua 3 giai đoạn: red, green, refactor",
          "Phải thực hiện việc test 2 lần để có ít bug"
        ],
        correct: 2
      },
      {
        question: "Phát biểu nào sau đây không phải là một trong những nguyên tắc của kiểm thử?",
        options: [
          "Lỗi thường phân bố tập trung",
          "Kiểm thử càng sớm càng tốt",
          "Kiểm thử phải đạt được 100% độ bao phủ",
          "Nghịch lý thuốc trừ sâu"
        ],
        correct: 2
      },
      {
        question: "Trong test double, đối tượng dummy khác với đối tượng fake như thế nào?",
        options: [
          "Dummy là đối tượng giả lập, fake là một đối tượng thật nhưng giả đối tượng khác",
          "Hai đối tượng này không khác nhau",
          "Fake là đối tượng giả lập, dummy là một đối tượng thật nhưng giả đối tượng khác",
          "Fake là giả hành vi, dummy là giả kết quả"
        ],
        correct: 3
      },
      {
        question: "Trình tự đúng của các giai đoạn kiểm thử phần mềm là:",
        options: [
          "Đơn vị - Tích hợp -> Hệ thống -> Chấp nhận",
          "Hệ thống - Đơn vị - Tích hợp -> Chấp nhận",
          "Tích hợp - Chấp nhận -> Đơn vị -> Hệ thống",
          "Đơn vị - Tích hợp - Chấp nhận - Hệ thống"
        ],
        correct: 0
      },
      {
        question: "Kiểm thử được thực hiện đầy đủ khi",
        options: [
          "Đạt độ tin cậy cần thiết được thiết lập trong test plan",
          "Người dùng hài lòng",
          "Hết thời gian",
          "Không tìm thấy lỗi nào nữa"
        ],
        correct: 0
      },
      {
        question: "Làm thế nào để chỉ định một phương thức kiểm thử cụ thể sẽ bị bỏ qua trong quá trình thực thi?",
        options: [
          "@Skip",
          "@IgnoreTest",
          "@Disabled",
          "@Avoid"
        ],
        correct: 2
      },
  {
    "question": "Kiểm thử chức năng được thực hiện khi nào?",
    "options": [
      "Chỉ được thực hiện ở mức kiểm thử đơn vị",
      "Được thực hiện ở tất cả các mức kiểm thử",
      "Chỉ được thực hiện ở mức kiểm thử chấp nhận",
      "Chỉ được thực hiện ở mức kiểm thử hệ thống và kiểm thử chấp nhận"
    ],
    "correct": 1
  },
  {
    "question": "Mục đích của điều kiện dừng trong kế hoạch kiểm thử là gì?",
    "options": [
      "để biết khi nào việc lập kế hoạch kiểm thử hoàn tất",
      "để cho biết cần phải kiểm thử bao nhiêu",
      "lập kế hoạch khi nào dừng chương trình",
      "để biết khí nào một bài kiểm thử cụ thể đã kết thúc quá trình thực hiện"
    ],
    "correct": 1
  },
  {
    "question": "Độ phức tạp chu trình của đoạn mã giả sau là bao nhiêu?\nIF XY THEN Statement 1;\nELSE IF Y Z THEN Statement 2; ENDIF\nENDIF",
    "options": [
      "5",
      "4",
      "2",
      "3"
    ],
    "correct": 3
  },
  {
    "question": "Chúng ta có thể tìm thấy điều kiện dừng kiểm thử trong tài liệu nào?",
    "options": [
      "Báo cáo kết quả kiểm thử",
      "Test suite",
      "Test case",
      "Test plan"
    ],
    "correct": 3
  },
  {
    "question": "Các bước cơ bản của quá trình kiểm thử dòng điều khiển",
    "options": [
      "Tính độ phức tạp chu trình để xác định loại đồ thị dòng điều khiển, xác định đường thi hành, sinh test case dựa vào đường thì hành",
      "Sinh đồ thị các test case từ code với độ đo cần kiểm thử, thực hiện các test case",
      "Sinh đồ thị dòng điều khiển CFG với tiêu chí độ đo cần kiểm thử, sinh các test case, thực hiện các test case",
      "Sinh đồ thị dòng điều khiển CFG với tiêu chí độ đo cần kiểm thử, sinh các đường thì hành, sinh các test case, thực hiện các test case"
    ],
    "correct": 3
  },
  {
    "question": "Kiểm thử tĩnh được thực hiện trong giai đoạn nào?",
    "options": [
      "Lập trình",
      "Thiết kế",
      "Tất cả các giai đoạn trên",
      "Đặc tả yêu cầu"
    ],
    "correct": 2
  },
  {
    "question": "Kiểm thử hệ thống (System Testing) được thực hiện khi nào?",
    "options": [
      "Trước khi kiểm thử tích hợp",
      "Trước khi kiểm thử Alpha",
      "Ngay sau kiểm thử module",
      "Ngay sau kiểm thử đơn vị"
    ],
    "correct": 1
  },
  {
    "question": "Cho đoạn mã sau và phát biểu nào sau đây đúng:\nIF A > B THEN C=A-B\nELSE C=B-A\nIF C = D Then Print \"Error\" ENDIF ENDIF",
    "options": [
      "3 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "1 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "2 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "2 test case để phủ các dòng lệnh, 2 test case để phủ nhánh"
    ],
    "correct": 2
  },
  {
    "question": "Kiểm thử alpha là:",
    "options": [
      "kiểm thử sau khi phát hành được thực hiện bởi người dùng cuối",
      "Kiểm thử đầu tiên được thực hiện",
      "Kiểm thử cuối cùng trước khi phát hành",
      "Kiểm thử trước khi phát hành được thực hiện bởi nhóm đại diện người dùng"
    ],
    "correct": 3
  },
  {
    "question": "Mục tiêu nào sau đây là mục tiêu của kiểm thử phần mềm?",
    "options": [
      "Xác định năng suất của lập trình viên",
      "Loại bỏ nhu cầu bảo trì chương trình trong tương lai",
      "Phát hiện lỗi có trong phần mềm",
      "Loại bỏ mọi lỗi trước khi phát hành"
    ],
    "correct": 2
  },
  {
    "question": "Mục tiêu chính khi review một giao phẩm phần mềm là gì?",
    "options": [
      "Để xác định code viết không theo chuẩn",
      "Để xác định các lỗi tiềm ẩn bằng cách sử dụng đặc tả kiểm thử",
      "Để xác định các lỗi chính tả trong một đặc tả yêu cầu",
      "Để xác định các khiếm khuyết trong bất kỳ sản phẩm của 1 công việc nào"
    ],
    "correct": 3
  },
  {
    "question": "Mục đích của kiểm thử chấp nhận để làm gì?",
    "options": [
      "Kiểm tra hệ thống có an toàn không",
      "Chứng minh tính bảo mật của hệ thống",
      "Kiểm tra xem hệ thống xử lý đúng nghiệp vụ không",
      "Chứng minh hệ thống không còn lỗi"
    ],
    "correct": 2
  },
  {
    "question": "Kiểm thử hộp trắng được áp dụng chủ yếu vào giai đoạn nào của kiểm thử phần mềm?",
    "options": [
      "Kiểm thử tích hợp",
      "Kiểm thử đơn vị",
      "Kiểm thử chấp nhận",
      "Kiểm thử hệ thống"
    ],
    "correct": 1
  },
  {
    "question": "Đâu không phải là mục tiêu của kiểm thử?",
    "options": [
      "Tăng sự tự tin về chất lượng của chương trình",
      "Ngăn chặn lỗi",
      "Tìm lỗi",
      "Tìm nguyên nhân lỗi"
    ],
    "correct": 3
  },
  {
    "question": "Mục tiêu quan trọng nhất của việc xác định test case là gì?",
    "options": [
      "Cái nào dễ thì test trước",
      "Tìm càng nhiều lỗi càng tốt",
      "Đạt được độ bao phủ cao",
      "Test các khu vực rủi ro cao"
    ],
    "correct": 3
  },
  {
    "question": "Kiểm thử hệ thống nên:",
    "options": [
      "Kiểm cả yêu cầu phi chức năng và yêu cầu chức năng",
      "Chỉ kiểm các yêu cầu phi chức năng không cần kiểm các yêu cầu chức năng",
      "Chỉ kiểm các yêu cầu chức năng không cần kiểm các yêu cầu phi chức năng",
      "Kiểm yêu cầu phi chức năng hoặc yêu cầu chức năng"
    ],
    "correct": 0
  },
  {
    "question": "Cái nào sau đây không phải là một phần của kiểm thử hệ thống:",
    "options": [
      "Kiểm tra sức chịu tải",
      "Kiểm thử tốc độ",
      "Kiểm tra tiêu chuẩn code",
      "Kiểm thử hiệu suất"
    ],
    "correct": 2
  },
  {
    "question": "Kỹ thuật đoán lỗi được sử dụng tốt nhất khi nào?",
    "options": [
      "Chỉ nên áp dụng 1 lần",
      "Khi tiếp cận đầu tiên để tạo ra các test case",
      "Bởi những người có nhiều kinh nghiệm",
      "Trước khi các kỹ thuật chính thức được áp dụng"
    ],
    "correct": 2
  },
  {
    "question": "Phát biểu nào đúng về mối quan hệ giữa bao phủ dòng lệnh và bao phủ quyết định?",
    "options": [
      "Bao phủ quyết định đạt 100% sẽ đảm bảo bao phủ lệnh 100%",
      "Bao phủ quyết định đạt 50% sẽ đảm bảo bao phủ lệnh 100%",
      "Bao phủ lệnh đạt 50% sẽ đảm bảo bao phủ quyết định 100%",
      "Bao phủ lệnh đạt 100% sẽ đảm bảo bao phủ quyết định 100%"
    ],
    "correct": 0
  },
  {
    "question": "Định nghĩa nào là phù hợp nhất về test case?",
    "options": [
      "Là một tập giá trị đầu vào và đầu ra mong đợi",
      "Là một cơ chế xác minh tính chính xác của kết quả đầu ra",
      "Là một trạng thái của hệ thống",
      "Là một cơ sở nguyên tắc về đo lường và thống kê"
    ],
    "correct": 0
  },
  {
    "question": "Lý do chính để kiểm thử phần mềm trước khi phát hành là gì?",
    "options": [
      "để tìm càng nhiều lỗi càng tốt trước khi phát hành",
      "để quyết định khi nào phần mềm có đủ chất lượng để phát hành",
      "để cung cấp thông tin cho một quyết định dựa trên",
      "để cho thấy hệ thống sẽ hoạt động sau khi phát hành"
    ],
    "correct": 1
  },
  {
    "question": "Trong kiểm thử tích hợp, ngoài cách tích hợp tăng dần (từ trên xuống, từ dưới lên) thì còn cách nào khác?",
    "options": [
      "Tích hợp trong kế hoạch lớn (big plan)",
      "Tích hợp theo chiều rộng (width)",
      "Tích hợp sandwich",
      "Tích hợp theo chiều sâu (deep)"
    ],
    "correct": 2
  },
  {
    "question": "Ưu điểm chính của phương pháp kiểm thử tích hợp dưới lên (Bottom-up) là gì?",
    "options": [
      "Không cần phải tạo stub",
      "Kiểm thử nhanh theo từng đơn vị",
      "Thiết kế ca kiểm thử dễ và không cần driver",
      "Kiểm thử ngay chức năng điều khiển hệ thống"
    ],
    "correct": 0
  },
  {
    "question": "Test suite được tạo ra trong giai đoạn nào?",
    "options": [
      "Phân tích yêu cầu",
      "Phát triển test case",
      "Lập kế hoạch",
      "Thiết lập môi trường"
    ],
    "correct": 1
  },
  {
    "question": "Trong một hệ thống tính thuế, nhóm nào trong số các nhóm sau rơi vào cùng một lớp tương đương?",
    "options": [
      "£5800; £28000; £32000",
      "£28001; £32000; £35000",
      "£5200; £5500; £28000",
      "£4800; £14000; £28000"
    ],
    "correct": 1
  },
  {
    "question": "Bạn đã thiết kế các test case để đạt 100% phủ lệnh và 100% phủ quyết định cho đoạn mã. Sau khi thêm các lệnh print, cần thêm bao nhiêu test case nữa?",
    "options": [
      "Thêm 2 test case nữa",
      "Thêm 1 test case nữa để đạt phủ cấp 2",
      "Thêm 1 test case nữa để đạt phủ cấp 1",
      "Không cần thêm test case nào nữa"
    ],
    "correct": 3
  },
  {
    "question": "Kiểm thử được thực hiện đủ khi nào?",
    "options": [
      "người dùng sẽ không tìm thấy bất kỳ lỗi nghiêm trọng nào",
      "Độ tin cậy cần thiết đã đạt",
      "Hết thời gian",
      "không tìm thấy lỗi nào nữa"
    ],
    "correct": 1
  },
  {
    "question": "Lỗi nào trong các lỗi sau tốn chi phí khắc phục nhất?",
    "options": [
      "Lỗi trong yêu cầu",
      "Lỗi trong đặc tả chương trình",
      "Lỗi trong thiết kế",
      "Lỗi trong code"
    ],
    "correct": 0
  },
  {
    "question": "Phát biểu nào sau đây không đúng về kiểm thử hồi quy?",
    "options": [
      "Để đảm bảo phần mềm sau khi sửa chữa không gặp thêm lỗi mới có liên quan",
      "Để tiết kiệm công sức phải kiểm thử lại toàn bộ hệ thống",
      "Để đảm bảo các test case mới không trùng với test case cũ",
      "Để đảm bảo phiên bản mới nhất của phần mềm không làm ảnh hưởng đến các chức năng đang hoạt động tốt"
    ],
    "correct": 2
  },
  {
    "question": "Cho đoạn mã giả sau, số test case tối thiểu để phủ 100% nhánh là bao nhiêu?\nif(x>y) x=x+1; else y=y+1; while(x>y) y=x*y; x=x+1;",
    "options": [
      "2",
      "3",
      "1",
      "4"
    ],
    "correct": 0
  },
  {
    "question": "Phát biểu nào đúng về độ bao phủ?",
    "options": [
      "Chỉ có thể được áp dụng trong kiểm thử đơn vị, không áp dụng trong kiểm thử hệ thống",
      "Là một thước đo về tính kỹ lưỡng của kiểm thử",
      "Không liên quan gì đến thử nghiệm",
      "Độ phủ nhánh phải là bắt buộc đối với tất cả phần mềm cho test case"
    ],
    "correct": 1
  },
  {
    "question": "Điều nào sau đây mô tả lợi ích chính của việc xác minh (verification) sớm trong vòng đời?",
    "options": [
      "Nó cho phép người kiểm thử sớm tham gia vào dự án",
      "Nó làm giảm sự gia tăng của lỗi",
      "Nó cho phép xác định các thay đổi trong yêu cầu của người dùng",
      "Nó tạo điều kiện cho việc thiết lập môi trường kiểm thử kịp thời"
    ],
    "correct": 1
  },
  {
    "question": "Thứ tự nào sau đây phù hợp với vòng đời bug?",
    "options": [
      "Open, Assigned, Fixed, Closed",
      "Assigned, Open, Closed, Fixed",
      "Assigned, Open, Fixed, Closed",
      "Open, Fixed, Assigned, Closed"
    ],
    "correct": 0
  },
  {
    "question": "Điều nào sau đây không được mô tả trong tiêu chuẩn kiểm thử đơn vị?",
    "options": [
      "Kiểm thử bảo mật",
      "Tiêu chuẩn code",
      "Kiểm tra lỗi chính tả",
      "Kiểm tra cú pháp"
    ],
    "correct": 0
  },
  {
    "question": "Để kiểm thử hàm tính thưởng theo phương pháp phân hoạch tương đương, cần tối thiểu bao nhiêu test case?",
    "options": [
      "4",
      "5",
      "2",
      "3"
    ],
    "correct": 0
  },
  {
    "question": "Mục tiêu quan trọng nhất của việc xác định độ ưu tiên kiểm thử là gì?",
    "options": [
      "Tìm càng nhiều lỗi càng tốt",
      "Đạt được độ bao phủ cao",
      "Test các khu vực rủi ro cao",
      "Cái nào dễ thì test trước"
    ],
    "correct": 2
  },
  {
    "question": "Xác định (verification) là:",
    "options": [
      "Kiểm thử xem chúng ta có đang xây dựng hệ thống đúng cách không",
      "Kiểm tra xem chúng ta có đang xây dựng hệ thống có phù hợp không",
      "Được thực hiện bởi một nhóm kiểm thử độc lập",
      "Đảm bảo rằng đó là những gì người dùng thực sự muốn"
    ],
    "correct": 0
  },
  {
    "question": "Khi kiểm thử hệ thống tính điểm tester xác định rằng tất cả các điểm từ 90–100 sẽ mang lại kết quả A, nhưng dưới 90 sẽ không được điểm.",
    "options": [
      "Phân tích lại",
      "Phân tích giá trị ranh giới",
      "Bảng quyết định",
      "Phân vùng tương đương"
    ],
    "correct": 1
  },
  {
    "question": "Chúng ta có thể tìm thấy điều kiện dừng kiểm thử trong tài liệu nào?",
    "options": [
      "Báo cáo kết quả kiểm thử",
      "Test suite",
      "Test case",
      "Test plan"
    ],
    "correct": 3
  },
  {
    "question": "Phát biểu nào sau đây đúng với kiểm thử beta?",
    "options": [
      "Được thực hiện bởi các chuyên gia",
      "Được thực hiện bởi coder",
      "Được thực hiện bởi người dùng cuối",
      "Được thực hiện bởi tester"
    ],
    "correct": 2
  },
  {
    "question": "Kiểm thử alpha là:",
    "options": [
      "Kiểm thử sau khi phát hành được thực hiện bởi người dùng cuối",
      "Kiểm thử trước khi phát hành được thực hiện bởi nhóm đại diện người dùng",
      "Kiểm thử đầu tiên được thực hiện",
      "Kiểm thử cuối cùng trước khi phát hành"
    ],
    "correct": 1
  },
  {
    "question": "Kiểm thử được thực hiện đủ khi:",
    "options": [
      "Độ tin cậy cần thiết đã đạt",
      "Hết thời gian",
      "Không tìm thấy lỗi nào nữa",
      "Người dùng sẽ không tìm thấy bất kỳ lỗi nghiêm trọng nào"
    ],
    "correct": 3
  },
  {
    "question": "Các test case được thiết kế khi nào?",
    "options": [
      "Khi có đặc tả hệ thống cần test",
      "Trong quá trình test",
      "Khi lập kế hoạch kiểm thử",
      "Khi cấu hình kiểm thử"
    ],
    "correct": 0
  },
  {
    "question": "Điều nào sau đây mô tả lợi ích chính của việc xác minh (verification) sớm trong vòng đời?",
    "options": [
      "Nó cho phép xác định các thay đổi trong yêu cầu của người dùng",
      "Nó làm giảm sự gia tăng của lỗi",
      "Nó cho phép người kiểm thử sớm tham gia vào dự án",
      "Nó tạo điều kiện cho việc thiết lập môi trường kiểm thử kịp thời"
    ],
    "correct": 1
  },
  {
    "question": "Điều quan trọng nhất về thiết kế kiểm thử sớm là:",
    "options": [
      "Làm cho việc chuẩn bị kiểm thử dễ dàng hơn",
      "Giúp tìm ra tất cả các lỗi",
      "Giúp việc kiểm thử nhanh hơn",
      "Có thể ngăn chặn sự nhân lên của lỗi"
    ],
    "correct": 3
  },
  {
    "question": "Nếu kết quả mong đợi (trong test case) không được xác định thì:",
    "options": [
      "Có thể khó lặp lại bài kiểm thử",
      "Có thể khó xác định test case là đạt hay không đạt",
      "Chúng ta không thể chạy kiểm thử",
      "Chúng ta không thể nhập tự động đầu vào của người dùng"
    ],
    "correct": 1
  },
  {
    "question": "Phát biểu nào sau đây là phát biểu đúng về review?",
    "options": [
      "Review không thể thực hiện dựa trên thông số kỹ thuật yêu cầu người dùng",
      "Review là cách kiểm tra mã kém hiệu quả nhất",
      "Review không có khả năng tìm ra lỗi trong kế hoạch kiểm thử",
      "Review được thực hiện dựa theo thông số kỹ thuật code và kế hoạch kiểm thử"
    ],
    "correct": 3
  },
  {
    "question": "Trong một hệ thống được thiết kế để tính thuế phải trả, nhóm nào trong số các nhóm sẽ rơi vào cùng một lớp tương đương?",
    "options": [
      "$4800 - $14000 - $28000",
      "$5800 - $28000 - $32000",
      "$5200 - $5500 - $28000",
      "$28001 - $32000 - $35000"
    ],
    "correct": 3
  },
  {
    "question": "Phát biểu nào sau đây đúng về kết quả mong đợi:",
    "options": [
      "Hữu ích nhất khi được xác định trước",
      "Chỉ được sử dụng trong kiểm thử đơn vị",
      "Không bao giờ được xác định trước",
      "Chỉ quan trọng trong kiểm thử hệ thống"
    ],
    "correct": 0
  },
  {
    "question": "Kiểm thử hộp trắng được áp dụng chủ yếu vào giai đoạn nào của kiểm thử phần mềm?",
    "options": [
      "Kiểm thử tích hợp",
      "Kiểm thử đơn vị",
      "Kiểm thử hệ thống",
      "Kiểm thử chấp nhận"
    ],
    "correct": 1
  },
  {
    "question": "Trong kiểm thử tích hợp, ngoài các tích hợp tăng dần thì còn cách nào khác?",
    "options": [
      "Tích hợp theo chiều rộng",
      "Tích hợp kế hoạch",
      "Tích hợp sandwich",
      "Tích hợp theo chiều sâu"
    ],
    "correct": 2
  },
  {
    "question": "Mục đích của điều kiện dừng trong kế hoạch kiểm thử là gì?",
    "options": [
      "Để biết khi nào một bài kiểm thử cụ thể đã kết thúc quá trình thực hiện",
      "Để đảm bảo rằng đã kiểm thử đầy đủ theo yêu cầu",
      "Để biết khi nào lập kế hoạch kiểm thử hoàn tất",
      "Lập kế hoạch khi nào dừng chương trình"
    ],
    "correct": 1
  },
  {
    "question": "Việc review hoặc inspection có thể được coi là một phần của kiểm thử không:",
    "options": [
      "Không, vì chúng thường được áp dụng trước khi thử nghiệm",
      "Không, vì chúng áp dụng cho tài liệu phát triển",
      "Không, vì chúng không áp dụng cho tài liệu kiểm thử",
      "Có, vì cả hai đều giúp phát hiện lỗi và cải thiện chất lượng"
    ],
    "correct": 3
  },
  {
    "question": "Các trường hợp kiểm thử chấp nhận được dựa trên những gì?",
    "options": [
      "Bảng quyết định",
      "Thiết kế",
      "Mã",
      "Yêu cầu"
    ],
    "correct": 3
  },
  {
    "question": "Cho đoạn mã giả sau, số test case tối thiểu để phủ 100% điều kiện là bao nhiêu?\nIf(x!=0 && x>y) \nx=x-y;\nElse Y=0; \nIf(x==0 || y==0 ) \ncout << 'khong';",
    "options": [
      "3",
      "2",
      "1",
      "4"
    ],
    "correct": 0
  },
  {
    "question": "Một input field nhận giá trị năm sinh trong [1000;2000], các giá trị biên để kiểm thử là:",
    "options": [
      "1000, 1001, 1500, 1999, 2000",
      "999, 1000, 1001, 1999, 2000",
      "0, 1900, 1990, 2000",
      "1000, 2000"
    ],
    "correct": 1
  },
  {
    "question": "Cho đoạn mã giả sau, số test case tối thiểu để phủ 100% nhánh là bao nhiêu?\nIf(x>y)\nx=x+1;\ny=y+1; \nWhile(x>y)\n  Y=x*y;\n x=x+1;",
    "options": [
      "2",
      "1",
      "3",
      "4"
    ],
    "correct": 0
  },
  {
    "question": "Kỹ thuật nào sau đây không phải là một hình thức của kiểm thử hộp trắng?",
    "options": [
      "Kiểm thử bao phủ dòng lệnh",
      "Kiểm thử đường dẫn cơ sở",
      "Kiểm thử dòng dữ liệu",
      "Bảng quyết định"
    ],
    "correct": 3
  },
  {
    "question": "Một hàm 'main' điều khiển việc đưa dữ liệu vào và nhận kết quả ra của module. Đối tượng giả lập của module A được gọi là gì?",
    "options": [
      "Input",
      "Driver",
      "Stub",
      "Output"
    ],
    "correct": 2
  },
  {
    "question": "Mục đích của kiểm thử chấp nhận là gì?",
    "options": [
      "Chứng minh thỏa mãn tất cả yêu cầu của khách hàng và khách hàng chấp nhận sản phẩm",
      "Chứng minh hệ thống không lỗi",
      "Chứng minh tính bảo mật của hệ thống",
      "Chứng minh tính tích hợp của hệ thống"
    ],
    "correct": 0
  },
  {
    "question": "Cho đoạn mã, phát biểu nào sau đây là đúng?\nSwitch pc on \nStart 'outlook' \nIf outlook appears \nthen Send an email \nElse Shutdown pc",
    "options": [
      "1 test case đủ phủ dòng lệnh, 1 test case phủ nhánh",
      "1 test case đủ phủ dòng lệnh, 2 test case phủ nhánh",
      "2 test case đủ phủ dòng lệnh, 2 test case phủ nhánh",
      "1 test case đủ phủ dòng lệnh, 3 test case phủ nhánh"
    ],
    "correct": 1
  },
  {
    "question": "Kiểm thử thiết kế và toàn bộ hệ thống (sau khi tích hợp) có thỏa mãn yêu cầu đặt ra hay không được gọi là gì?",
    "options": [
      "Kiểm thử hệ thống",
      "Kiểm thử chấp nhận",
      "Kiểm thử đơn vị",
      "Kiểm thử tích hợp"
    ],
    "correct": 0
  },
  {
    "question": "Kiểm thử hệ thống phi chức năng bao gồm:",
    "options": [
      "Kiểm thử để xem hệ thống có thực hiện đúng luồng xử lý không",
      "Kiểm thử khả năng phục hồi của hệ thống",
      "Kiểm thử một tính năng để đáp ứng cho một hành động",
      "Kiểm thử các chức năng không nên tồn tại"
    ],
    "correct": 1
  },
  {
    "question": "Kiểm thử hệ thống (System Testing) được thực hiện trước khi:",
    "options": [
      "Kiểm thử đơn vị",
      "Kiểm thử module",
      "Kiểm thử chấp nhận",
      "Kiểm thử tích hợp"
    ],
    "correct": 2
  },
  {
    "question": "Kỹ thuật đoán lỗi được sử dụng tốt nhất:",
    "options": [
      "Khi tiếp cận đầu tiên để tạo ra các test case",
      "Sau khi các kỹ thuật chính thức được áp dụng",
      "Bởi những người thử nghiệm thiếu kinh nghiệm",
      "Sau khi hệ thống hoạt động"
    ],
    "correct": 1
  },
  {
    "question": "Cho đoạn mã, phát biểu nào sau đây là đúng:\nIF A > B\nTHEN C =A -B \nRead D \nIF C =D \nThen Print 'Error' \nENDIF \nENDIF",
    "options": [
      "1 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "2 test case để phủ các dòng lệnh, 2 test case để phủ nhánh",
      "2 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "3 test case để phủ các dòng lệnh, 3 test case để phủ nhánh"
    ],
    "correct": 2
  },
  {
    "question": "Đầu vào nào sau đây thuộc cùng 1 lớp tương đương trong khoảng [1000 - 99999]?",
    "options": [
      "10000 - 50000 - 999999",
      "1000 - 5000 - 10000",
      "10000 - 999999",
      "9999 - 50000 - 100000"
    ],
    "correct": 1
  },
  {
    "question": "Nội dung nào sau đây không có trong tài liệu test plan?",
    "options": [
      "Những gì không được kiểm tra",
      "Môi trường thử nghiệm",
      "Kế hoạch để đánh giá chất lượng",
      "Lịch trình và thời hạn"
    ],
    "correct": 2
  },
  {
    "question": "Điều nào sau đây không đúng với điều kiện phủ của kiểm thử?",
    "options": [
      "Các điều kiện phủ thường được sử dụng khi chỉ định các tiêu chí hoàn thành kiểm thử",
      "Thước đo điều kiện phủ là tỷ lệ phần trăm yêu cầu của người dùng được phủ",
      "Thước đo điều kiện phủ kiểm thử là tỷ lệ phần trăm lệnh được thực thi",
      "Cho biết số lỗi còn lại trong hệ thống"
    ],
    "correct": 3
  },
  {
    "question": "Cho đoạn mã, số lượng test case tối thiểu cần thiết cho toàn bộ báo cáo và phạm vi nhánh là:\nRead P\nRead Q\nIF P+Q > 100 \nTHEN Print 'large' \nELSE IF P>50 \nTHEN Print 'P large'\nENDIF \nENDIF",
    "options": [
      "1 test case để phủ các dòng lệnh, 1 test case để phủ nhánh",
      "1 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "2 test case để phủ các dòng lệnh, 3 test case để phủ nhánh",
      "1 test case để phủ các dòng lệnh, 2 test case để phủ nhánh"
    ],
    "correct": 2
  }